# 42_CPP_Module_07

# Global Goal

Discover the use of templates in C++ for functions and classes in OOP.

---

# Templates

C++ Templates are a powerful technique used to create **generic** classes or functions. They allow us to write code that works for multiple data types without repeating the same code for each case (for example: writing one version for `int` and another for `double`).

### Key features:
- **Avoid code duplication**: Great for the **DRY** (Don't Repeat Yourself) principle.
- **Type safety**: Unlike macros, templates provide type safety because the compiler checks the types during instantiation.
- **Specialization**: Can be specialized for a specific data type when a unique implementation is needed.
- **Foundation of the STL**: Templates provide the basis for the Standard Template Library (STL), which contains built-in implementations of commonly used data structures known as containers.



```cpp
template <typename T> // Defines the template parameter. Its scope is strictly limited to the function. 
T myMax(T x, T y)      // Function template definition. 
{
    return (x > y ? x : y);
}

int main()
{
    // Using myMax with explicit template arguments in angle brackets <>
    std::cout << "Max of 3 and 7 is: " << ::myMax<int>(3, 7) << std::endl; 
    
    // Using myMax with type deduction (the compiler figures out the type for you)
    std::cout << "Max of 3.5 and 7.5 is: " << ::myMax(3.5, 7.5) << std::endl;
    std::cout << "Max of 'g' and 'e' is: " << ::myMax('g', 'e') << std::endl;
    
    return 0;
}
```

## Definitions:

    Primary Template: The initial template used to generate other functions.

    Instantiated Functions: The specific functions generated by the compiler for a particular type (e.g., the version created for int).

    Template Parameter (T): Acts as a placeholder for any type. It is declared using template <typename T> inside angle brackets <>. T can be any type, such as int, double, float, or even custom classes.

## Instantiating a function template

Function templates are not actually functions. The code is not compiled or executed directly. Instead, when the compiler sees a call to a template, it uses the "blueprint" to generate a real function for that specific data type. This process is called instantiation. It is also called specialisation.

## Using static variables in templates

Careful with modifiable static local variables. The template is just a  blueprint, and so the compiler creates entirely separate functions for int, double and any other type you use.

see learncpp.com 

```cpp
int main() {
    countCalls<int>();    // Output: Count: 1
    countCalls<int>();    // Output: Count: 2
    
    countCalls<double>(); // Output: Count: 1 (Starts over because it's a new function!)
    countCalls<int>();    // Output: Count: 3 (Goes back to the 'int' version's memory)
}
```

---

ex00

Goal: We need to implement three function templates:

    swap: Swaps the values of two arguments. It does not return anything.

    min: Compares two arguments and returns the smallest one. If they are equal, it returns the second one.

    max: Compares two arguments and returns the greatest one. If they are equal, it returns the second one.

Because it is specified that we need to only accept ONE TYPE, we can only have one typename T and not 

```cpp
<typename T, typename U>
```

if we define x with template type T and y with template type U, the compiler iwll happily use max(int, double).

---

## ex02

Just like we can have function templates, we can have class templates allowing member functions to have members that use Templates as types

for example 

```cpp 
Class car
{
    Car();
    Car(const Car &other);
    Car& operator=(const Car &other);
    ~Car()
}
```

here the type of the class is Car.

```cpp
template <typename T>
Class Car
{
    Car();
    Car(const Car &other);
    Car& operator=(const Car &other);
    ~Car()
}

template <typename T>
Car<T>::Car() {}

template <typename T>
Car<T>::Car(const Car<T>& other) {}
etc.
```

In this excercise, we define a class template Array, and this Array container could contain doubles or int
according to what we send to it with 

```cpp
Array<int> intArray();
Array<double> doubleArray();
```

it would replace this piece of code:

```cpp
template <typename T>
Array<T>::Array(unsigned int n) : array(new T[n]()), size(n)
{
	// a constructor does not return anything, maybe thats the first step
	std::cout << "constructor called with n" << std::endl;
	std::cout << this->array << std::endl;
}
```

it sees the template definition, and it replaces every occurence of T with int. 
with this one:

```cpp
Array<int>::Array(unsigned int n) : array(new int[n]), size(n)
{
    ...
}
```
